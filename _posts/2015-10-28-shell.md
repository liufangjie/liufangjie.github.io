---
layout: post
title: shell脚本
---
{{ page.title }}
================

# Basic

[Linux初心者のシェルスクリプト入門](https://qiita.com/lrf141/items/6c01d2f7afff79cd7286)

# 文件对比去重

`comm -23 file1 file2 `

参考：

[how-to-remove-the-lines-which-appear-on-file-b-from-another-file-a](https://stackoverflow.com/questions/4366533/how-to-remove-the-lines-which-appear-on-file-b-from-another-file-a)

[deleting-lines-from-one-file-which-are-in-another-file](https://stackoverflow.com/questions/4780203/deleting-lines-from-one-file-which-are-in-another-file)

# 按照名字查找文件

`find . -name "foo*"`

注意要使用双引号

[how-can-i-recursively-find-all-files-in-current-and-subfolders-based-on-wildcard](https://stackoverflow.com/questions/5905054/how-can-i-recursively-find-all-files-in-current-and-subfolders-based-on-wildcard)

# how-to-output-text-to-both-screen-and-file-inside-a-shell-script 将echo同时输出到屏幕和日志文件

```
command | tee -a "$log_file"
```

[how-to-output-text-to-both-screen-and-file-inside-a-shell-script](https://unix.stackexchange.com/questions/80707/how-to-output-text-to-both-screen-and-file-inside-a-shell-script)

# 查找文本

```
grep -rnw '/path/to/somewhere/' -e 'pattern'
```

[how-do-i-find-all-files-containing-specific-text-on-linux](https://stackoverflow.com/questions/16956810/how-do-i-find-all-files-containing-specific-text-on-linux)

# 按分隔符拆分字符串并获取指定字符串

```
$ s='one_two_three_four_five'

$ A="$(cut -d'_' -f2 <<<"$s")"
$ echo "$A"
two

$ B="$(cut -d'_' -f4 <<<"$s")"
$ echo "$B"
four
```

[split-string-by-delimiter-and-get-n-th-element](https://unix.stackexchange.com/questions/312280/split-string-by-delimiter-and-get-n-th-element)

# cd到上一个目录 how-to-go-to-the-previous-working-directory-in-terminal

`cd -`

`cd $OLD_PWD`

[how-to-go-to-the-previous-working-directory-in-terminal](https://unix.stackexchange.com/questions/81224/how-to-go-to-the-previous-working-directory-in-terminal)

# 删除有乱码的文件或目录

文件或目录有乱码导致无法通过屏幕输入文件或目录名，可以通过incode进行删除

方法，找到inode并删除

`ls -i`

`find ./ -inum nodenum -print -exec rm {} -rf \;`

nodenum为ls -i看到inode号

# 取当前目录

    #!/bin/bash

    SOURCE="${BASH_SOURCE[0]}"
    while [ -h "$SOURCE" ]; do # resolve $SOURCE until the file is no longer a symlink
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null && pwd )"
    SOURCE="$(readlink "$SOURCE")"
    [[ $SOURCE != /* ]] && SOURCE="$DIR/$SOURCE" # if $SOURCE was a relative symlink, we need to resolve it relative to the path where the symlink file was located
    done
    DIR="$( cd -P "$( dirname "$SOURCE" )" >/dev/null && pwd )"

[getting the source directory of as bash script from whithin](https://stackoverflow.com/questions/59895/getting-the-source-directory-of-a-bash-script-from-within)

# 端口号占用

windows:

`netstat -ano | findstr {查询端口号}`

# /dev/null 2>&1

[/dev/null 2>&1](http://stackoverflow.com/questions/10508843/what-is-dev-null-21)

>> /dev/null redirects standard output (stdout) to /dev/null, which discards it.

(The >> seems sort of superfluous, since >> means append while > means truncate and write, and either appending to or writing to /dev/null has the same net effect. I usually just use > for that reason.)

2>&1 redirects standard error (2) to standard output (1), which then discards it as well since standard output has already been redirected.

# 查看端口情况

`netstat -ntlp`

# 按名称查找进程

`ps -ef | grep tomcat`

# 统计tcp状态

`netstat -n | awk '/^tcp/ {++y[$NF]} END {for(w in y) print w, y[w]}'`

# 截取文本文件中指定范围的文本内容并输出到新文本，日志分析，文本内容查找

[sed, a stream editor](https://www.gnu.org/software/sed/manual/sed.html)

1. 通过grep找到要截取的文本所在行号`cat -l | grep "要查找的文本内容"`

2. 通过sed命令，截取并输出到新文本`sed -n 'start-line_num,end_line_nump' input.txt > output.txt`

例如：`sed -n '100,200p' input.txt > output.txt`

上述命令将input.txt的第100行到200行截取后输出到output.txt

# 常见命令

1. `grep -n 'text' filename.suffix` 在filename.suffix中搜索'text'

2. \cp -rf test test1 拷贝test到test1目录下文件存在直接覆盖，命令前加入斜杠不会提示是否覆盖，否则由于cp命令一般有默认的-i选项所以会出现是否覆盖的提示

3. 端口监听`netstat`

# 循环

declare -i i=1

while ((i<1000))

do

  这里放要执行的命令
  
  let i++
  
done

# 进程查看及操作

1. windows：

`netstat -nao` //列出所有进程以及其占用的端口

记住进程号

`taskkill -PID 进程号 -F`  //强制关闭某个进程

2. linux：

`netstat -naop`

`kill 进程号 -f`
